Andre: A High Performance Asynchronous Decentralized Application Platform
Disclaimer
This article is translated from the Andre Russian version of the white paper published on andre.com. It is translated by the community enthusiast Keryiwa and other members with the technical support of the Andre project. The community members and other interested friends understand the project and are not used for any commercial purposes. Promotion.
This paper, as a technical white paper, describes the current and future technological developments of the Andre ecosystem. This document is for informational purposes only and is not a statement of future intent.
Although Keryiwa et al. endeavor to ensure that the factual statements described herein are accurate, all estimates, forecasts, forecasts, prospects, opinions, and other subjective judgments contained in this document are based on assumptions that are considered reasonable by the date of this document and may not be Explain that the statement is about to happen. Any plans, forecasts or forecasts mentioned herein may not be realized due to a variety of risk factors, including but not limited to technological developments, legal or regulatory risks, market volatility, sector changes, corporate actions or the inability to obtain complete and accurate information.
Abstract
Andre is a generalised decentralized application platform that meets the requirements of industrial applications for high throughput, low latency and scalability while taking into account security. Andre uses DAG ledger structure, and transactions in ledgers are grouped by accounts. The Snapshot Chain structure in Andre can make up for the lack of security of the DAG ledger. The HDPoS consensus algorithm, through which writing and confirming of transactions are asynchronous, provides high performance and scalability. The Andre VM is compatible with EVM, and the smart contract language extended from Solidity, providing more powerful ability of description. In addition, an important improvement in Andre design is the adoption of a asynchronous Event Driven Architecture, which transmits information through messages between smart contracts, which greatly improves system throughput and scalability. In addition to built-in native tokens, Andre also supports users to issue their own digital assets, and also provides cross chain value transfer and exchange based on Loopring Protocol [1]. Andre realizes resource allocation by quotas, and light users do not have to pay transaction fees. Andre also supports contract scheduling, name service, contract update, block pruning and other features.

1 Introduction
1.1 Definition
Andre is a universal dApp platform that can support a set of smart contracts, each of which is a state machine with independent state and different operational logic, which can communicate by message delivery.
In general, the system is a transactional state machine. The state of the system s ∈ S, also known as the world state, is composed of the state of each independent account. An event that causes changes in account status is called transactions. The more formalized definition is as follows:
Definition 1.1 (Transactional State Machine) a transactional state machine is a 4-tuple: (T ,S, g, δ),where T is a set of transactions,S is a set of states,g ∈ S is the
initial state, also known as genesis block, δ : S × T → S is a state transition function.
The semantics of this transactional state machine is a discrete transition system, which is defined as follows:
Definition 1.2 (Semantics of Transactional State Machine)
The semantics of a transactional state machine (T ,S, s0, δ) is a discrete transition system: (S, s0, →).→∈ S × S is a transition relationship.
At the same time, the decentralized application platform is a distributed system with final consistency. Through some consensus algorithm, the final state can be reached between nodes. In realistic scenarios, what is stored in the state of smart contracts is a set of completed data in a decentralized application, with large volume and can not be transmitted between nodes. Therefore, nodes need to transfer a set of transactions to achieve the consistency of the final state. We organize such a group of transactions into a specific data structure, usually referred to as ledgers.
Definition 1.3 (Ledger) Ledger is composed of a set of transactions, with an abstract data type recursively constructed. It is defined as follows:
l = Γ(Tt)
l = l1 + l2
Among them,Tt ∈ 2T ,representing a set of transactions,Γ ∈ 2T → L,represents a function
of constructing a bookthrough a set of transactions,L is a set of ledgers,+ : L×L →L,representing the operation of merging two sub ledgers intoone.
It should be noted that in such systems, ledgers areusually used to represent a group of transactions, rather than a state. In Bitcoin [2]and Ethereum [3],the ledgeris a block chain

structure, where transactions are globally ordered. To modify a transaction in the ledger, we need to reconstruct a sub ledger in the account book, thereby increasing the cost of tampering with the transaction.
According to the same group of transactions, different valid books can be constructed, but they represent a different order of transactions and may cause the system to enter a different state. When this happens, it is usually called”fork”.
Definition 1.4 (Fork) Assume Tt, Tt′ ∈ 2T,Tt ⊆ Tt′. ifl = Γ1(Tt),l′ = Γ2(Tt′),and don’ t meet l ⪯ l′,we can name land l′ are fork legers. ⪯ represents prefix relitionship.
According to the semantics of the transactional state machine, we can easily prove that from an initial state, if the ledger is not forked, each node will eventually enter the same state. So, if a forked ledger is received, will it certainly enter a different state? It depends on the inherent logic of the transaction in the ledger, and howthe ledgers organize partial orders between transactions. In reality, there are often some transactions that satisfy the commutative laws, but because of the problem of account design, they frequently cause forks. When the system starts from an initial state, receives two forked ledgers and ends up in the same state, we call these two ledgers a false forked ledger.
Definition 1.5 (False Fork) Initial state s0 ∈ S,ledgerl1, l2 ∈ L,s0 →l1 s1, s0 →l2 s2. if l1 = l2,and s1 = s2,we call these two ledgers l1, l2 as false fork ledgers.
A well designed ledger should minimize the probability of false fork
When the fork occurs, each node needs to choose one from multiple forked ledgers. In order to ensure the consistency of the state, the nodes need to use the same algorithm to complete the selection. This algorithm is called the consensus algorithm.
Definition 1.6 (Consensus Algorithm) Consensus algorithm is a function that receives a set of ledgers and returns the only ledger:
Φ : 2L → L
Consensus algorithm is an important part of system design. A good consensus algorithm
should possess high convergence speed to reduce the sway of consensus in different forks, and have a high ability to guard against malicious attacks.
1.2 Current Progress
The Ethereum [4]took the lead in realizing such a system. In the design of the Ethereum, the definition of the worldstate is S = ΣA, a mapping from the account a ∈ A and the state of this account σa ∈ Σ.Therefore, any state in the state machine of the Ethereum is global, which means that a node can achieve the status of any account at any time.
The state transition function δ of Ethereum is defined by a set of program codes. Each group of code is called a smart contract. The Ethereum defines a Turing complete virtual machine, called EVM, whose instruction set is called EVM code. Users can develop smart contracts through a programming language Solidity similar to JavaScript, and compile them into EVM code, and

deploy them on Ethereum [5]. Once the smart contract is successfully deployed, it is equivalent to defining contract account a receives the state transition function δa. EVM is widely used in such platforms, but there are also some problems. For example, there is a lack of library function support and security problems.
The ledger structure of the Ethereum is a block chain[2]the block chain is made up of blocks, each block contains a list of transactions, and the latter block refers to the hash of the previous block to form a chain structure.
Γ({t1, t2, ...|t1, t2, ... ∈ T}) = (...,(t1, t2, ...)) (1)
The greatest advantage of this structure is to effectively prevent transactions from being tampered with, but because it maintains the full order of all transactions, the exchange of two transaction orders will generate a new ledger, which has a higher probability of fork. In fact, under this definition, the state space of a transactional state machine is regardedas a tree: the initial state is the root node, the different transaction order represents different paths, and the leaf node is the final state. In reality, the state of a large number of leaf nodes is the same, which leads to a large number offalse forks.
The consensus algorithm Φ is called PoW, which firstproposed in Bitcoin protocol [2].The PoW algorithm relies on a mathematical problem that is easily verifiable but difficult to solve. For example, based on a hash function h : N → N,finding the result of x,to meet the requirement h(T + x) ≥ d,dis a given number, called the difficulty, T is a binary representation of the trade list contained in the block. Each block in the block chain contains a solution to such problems. Add up the difficulty of all blocks, which is the total difficulty of a block chain ledger:
D(l)=D( ∑ ili)= ∑ iD(li)(2)
Therefore, when choosing the correct account from the fork, choose the fork with the
highest difficulty:
Φ(l1, l2, ..., ln) = lm where m = arg max(D(li)) (3)
The PoW consensus algorithm has better security and has been running well in Bitcoin and Ethereum. However, there are two main problems in this algorithm. The first is to solve a mathematical problem that requires a large amount of computing resources, resulting in a waste of energy. The second is the slow convergence speed of the algorithm, thus affecting the system s overall throughput. At present, the TPS of the Ethereum is only about 15, which is totally unable to meet the needs of decentralized applications.
1.3 Direction of Improvement
After the birth of the Ethereum, the Ethereum community and other similar projects began to improve the system from different directions. From the abstract model of the system,the

following directions can be improved:
• Improving the system state S
• Improving the state transition function δ • Improving the structure of the ledger Γ • Improving the consensus algorithm Φ
1.3.1 Improve the state of the system
The main idea of improving the state of the system is to localize the global state of the world, each node is no longer concerned with all transactions and state transfers, and only maintains a subset of the whole state machine. In this way, the potentials of the set S and the set T are greatly reduced, thus improving the scalability of the system. Such systems include: Cosmos [6],Aelf[7],PChain and so on.
In essence, this side chain based scheme sacrifices the wholeness of the system state in exchange for the scalability. This makes the decentralization of each dApp running on it is weakened - the transaction history of a smart contract is no longer saved by every node in the whole network, but only by a part of the node. In addition, cross contract interaction will become the bottleneck of such a system. For example, in Cosmos, interactions in different Zone require a common chain Hub to complete [6].
1.3.2 Improve state transition function
Based on improving EVM, some projects provide more abundant smart contract programming languages. For example, a smart contract language Rholang is defined in RChain based on π calculus ; the smart contract in NEO is called NeoContract, which can be developed in the popular programming languages such as Java,C# etc; EOS is programmed with C/C++.
1.3.3 Improve the ledger structure
The improvement direction of the ledger structure is the construction of the equivalent class. The linear ledger with the global order of multiple transactions is improved to a nonlinear ledger that only records partial order relations. This nonlinear ledger structure is a DAG (Directed Acyclic Graph). At present, Byteball [8],IOTA[9],Nano[10]and otherprojects have realized the function of

encrypting money based on DAG’s account structure. Some projects are trying to use DAG to implement smart contracts, but so far, improvements in this direction are still being explored.
1.3.4 Improve consensus algorithm
The improvement of consensus algorithm is mostly to improve the throughput of the system, and the main direction is to suppress the generation of false fork. Next we will discuss what factors are involved in false fork.
As shown,L is a collection of all possible forked accountsfor a set of transactions, and S is a collection of states thatcan be reached in different orders. According to definition,1.4, mapping f : L → S is a surjective;And according todefinition 1.5, this mapping is not a injective. Here we calculate the probability of the false fork:
Suppose that C users have the right to produce ledgers,From this formula, we can see that in order to reduce the probability of false fork, there are two ways:
• ff Establish equivalence relations on the L of the ledger set, divide equivalence classes into them, and construct fewer forked ledgers.
• ff Restrict users who have the right to produce ledgers, thereby reducing C
The first way is the important direction in Andre design. It will be discussed in detail later. The second ways have been adopted by many algorithms. In the PoW algorithm, any user has the right to produce a block; and the PoS algorithm limits the power of the production block to those with system rights; the DPoS algorithm [11] limits the user with the right to produce the block to be further restricted within a group of agent nodes.
At present, through improved consensus algorithm, some influential projects appeared. For example, Cardano uses a PoS algorithm called Ouroboros, and literature [12] gives a strict proof of the related characters of the algorithm; BFT-DPOS algorithm used by EOS[13], is a variant of the DPoS algorithm and improves system throughput by fast producing blocks; Qtum [14]’s consensus algorithm is also a PoS algorithm; The Casper algorithm adopted by RChain[15] is one of the PoS algorithms as well.
There are also other projects that put forward their own proposals for improving the consensus algorithm. NEO[16] uses a BFT algorithm, called dBFT, and Cosmos[6] uses an algorithm called Tendermint .
2 Ledgers

2.1 Overview
The role of ledgers is to determine the order of transactions, and the order of transactions will affect the following two aspects:
• Consistency of status: Since the state of the system is not a CRDT (Conflict-free replicated data types) [18], not all transaction is exchangeable, and the sequence of different transaction execution may lead to the system entering a different state.
• Effectiveness of Hash: In the ledger, the transaction will be packaged into blocks, which contain hash that is referenced each other. The order of transactions affects the connectivity of hash quoted in the ledgers. The greater the scope of this impact, the greater the cost of tampering with transactions. This is because any change to a transaction must be rebuilt by hash, which directly or indirectly refers to the block of the transaction..
The design of the ledger also has two main objectives:
• Reducing the false fork rate: as discussed in the previous section, the reduction of the false fork rate can be achieved by establishing an equivalent class and combining a group of accounts that lead the system into the same state into a single account. As shown above, according to the formula of false fork rate, the false fork rate of the ledger on the left is Pf f = ( 3 5 )C + ( 2 5 )C − 1 5C−1 ;after the merge of ledger space, the false fork rate of the right graph is Pff′=(23)C+(13)C − 13C−1.ItisknownthatwhenC>1,Pff′<Pff.Thatistosay, we should minimize the partial ordering relationship between transactions and allow more transactions to be exchanged sequentially.
• Tamper proof: when a transaction t is modified in the ledger l,in the two sub ledgers of the book l = l1 + l2, the sub ledger l1 is not affected, and the hash references in the sub ledger l2 need to be rebuilt to form a new valid ledger l ′ = l1 + l2 ′ . Affected sub ledger l2 = Γ(T2), T2 = {x|x ∈ T, x > t}.Thus, to increase the cost of tampering with transactions, it is necessary to maintain the partial order relationship between transactions as much as possible in order to expand the scope of tampering |T2|.
Obviously, the above two objectives are contradictory, and the necessary trade-offs must be made when designing the account structure. Since the account maintenance is a partial order between transactions, it is essentially a partial ordered set (poset) [19], if represented by Hasse diagram (Hasse diagram)[20], it is a DAG on the topology.
The above picture compares several common ledger structures, and the ledgers near the left are maintained with less partial order. Hasse diagram appears flat and has a lower false fork rate; the ledgers near the right side maintain more partial order relationships, and Hasse diagram is more slender and more tamper resistant.
In the picture, the most-left side is a common set based structure in a centralization system

without any tamper proofing features; the most right side is a typical blockchain Ledger with the best tamper proof features; between the two, there are two DAG ledgers, the block-lattice account [10] used by Nano on the left; and the right side, the tangle book [9] is used by IOTA . In terms of characteristics, blocklattice maintains less partial order relations and is more suitable for the accounting structure of high performance decentralized application platforms. Because of its poor tampering characteristics, it can expose security risks, so far, no other projects adopt this ledger structure except Nano.
In order to pursue high performance, Andre adopts the DAG ledger structure. At the same time, by introducing an additional chain structure Snapshot Chain and improving the consensus algorithm, the shortcomings of block-lattice security are successfully made up, and the two improvements will be discussed in detail later.
2.2 Pre Constraint
First, let’s take a look at the precondition of using this ledger structure for the state machine model. This structure is essentially a combination of the entire state machine as a set of independent state machines, each account corresponding to an independent state machine, and each transaction only affects the state of an account. In the ledger, all transactions are grouped into accounts and organized into a chain of transactions in the same account. Therefore, we have the 4 following restrictions on the state S and transaction T in Andre:
Definition 2.1 (Single degree of freedom constraint) system state s S,is the vector s = (s1, s2, ..., sn) formed by the state si of each account. For 